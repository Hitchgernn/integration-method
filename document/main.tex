
\documentclass[a4paper, 11pt]{article} % Diambil dari main.tex 

% --- Paket-paket dari main.tex ---
\usepackage[utf8]{inputenc} % 
\usepackage[T1]{fontenc} % 
\usepackage{amsmath} % 
\usepackage{amssymb} % 
\usepackage[bahasa]{babel} % 
\usepackage[margin=1in]{geometry} % (Menggantikan setting geometry dari )
\usepackage{listings} % 
\usepackage{xcolor} % 
\usepackage{booktabs} % 
\usepackage{hyperref} % 
\usepackage{float} % 
\usepackage{caption} % 
\usepackage{subcaption} % 
\usepackage{graphicx} % 

% --- Paket tambahan dari cover.tex ---
\usepackage{setspace} % 

% --- PENGATURAN TAMPILAN KODE (dari main.tex) ---
\definecolor{codegreen}{rgb}{0,0.6,0} % 
\definecolor{codegray}{rgb}{0.5,0.5,0.5} % 
\definecolor{codepurple}{rgb}{0.58,0,0.82} % 
\definecolor{backcolour}{rgb}{0.95,0.95,0.95} % 

\lstdefinestyle{mystyle}{ % 
    backgroundcolor=\color{backcolour},   % 
    commentstyle=\color{codegreen}, % 
    keywordstyle=\color{blue}, % 
    numberstyle=\tiny\color{codegray}, % 
    stringstyle=\color{codepurple}, % 
    basicstyle=\ttfamily\small, % 
    breakatwhitespace=false,         % 
    breaklines=true,                 % 
    captionpos=b,                    % 
    keepspaces=true,                 % 
    numbers=left,                    % 
    numbersep=5pt,                   % 
    showspaces=false,                % 
    showstringspaces=false, % 
    showtabs=false,                  % 
    tabsize=2 % 
}
\lstset{style=mystyle} % 

% --- JUDUL DOKUMEN (dari main.tex, untuk metadata) ---
\title{Perbandingan Metode Integrasi Numerik} % 
\author{Analisis Perhitungan $\int \cos(x) \, dx$ dan $\int x^2 \, dx$} % 
\date{\today} % 

% ======================================================
%               AWAL DOKUMEN
% ======================================================
\begin{document}

% --- KONTEN HALAMAN COVER (dari cover.tex) ---
\thispagestyle{empty} % 
\begin{center} % 

% --- Judul Utama ---
{\Large \textbf{PROYEK METODE NUMERIS}}\\[0.5cm] % <-- [PERUBAHAN 1: Menambahkan spasi 0.5cm]

{\large \textbf{NUMERICAL INTEGRATION DENGAN METODE EXTRAPOLATION, ROMBERG INTEGRATION, ADAPTIVE INTEGRATION, DAN GAUSSIAN QUADRATURE}}\\[2cm] % 

% --- Logo ---
\includegraphics[width=0.5\textwidth]{images.png}\\[2cm] % 

% --- Disusun oleh ---
{\large \textbf{Disusun oleh:}}\\[0.5cm] % 

% --- [PERUBAHAN 2: Menggunakan tabular untuk merapikan nama, NIM, dan nomor] ---
{\normalsize % 
\begin{tabular}{l l}
1. Adnan Abdul Majid & (24/544058/TK/60471) \\
2. Muhammad Ilkham Abdillah & (24/537977/TK/59653) \\
3. Rafif Raihan Bahrul Alam & (24/534432/TK/59237) \\
4. Rakan Hendian Ramadhan & (24/540158/TK/59909)
\end{tabular}
}\\[5cm] % 
% --- [AKHIR PERUBAHAN 2] ---

% --- Institusi ---
{\large \textbf{Departemen Teknik Elektro dan Teknologi Informasi}}\\[0.3cm] % 
{\large \textbf{Universitas Gadjah Mada}} % 

\end{center} % 
% --- AKHIR KONTEN HALAMAN COVER ---

\newpage % Memulai halaman baru setelah cover

% --- KONTEN UTAMA (dari main.tex) ---

\pagestyle{plain}
\setcounter{page}{1}

\tableofcontents % 
\newpage % 

\section{Pengantar} % 

Integrasi numerik adalah proses fundamental dalam sains dan rekayasa untuk mengestimasi nilai integral tertentu $\int_a^b f(x) \, dx$ ketika solusi analitik (solusi eksak) sulit atau tidak mungkin ditemukan. % 
Terdapat berbagai metode untuk melakukan estimasi ini, masing-masing dengan kelebihan, kekurangan, dan tingkat akurasi yang berbeda. % 
Dalam laporan ini, kita akan menganalisis dan membandingkan empat metode integrasi numerik yang populer: % 
\begin{enumerate}
    \item \textbf{Aturan Trapesium (Trapezoidal Rule)} sebagai metode dasar, dan \textbf{Ekstrapolasi Richardson} sebagai teknik untuk meningkatkan akurasinya. % 
    \item \textbf{Integrasi Romberg}, yang merupakan aplikasi sistematis dari Ekstrapolasi Richardson pada Aturan Trapesium. % 
    \item \textbf{Integrasi Adaptif (Adaptive Quadrature)}, sebuah metode cerdas yang menyesuaikan ukuran langkahnya secara dinamis untuk efisiensi. % 
    \item \textbf{Kuadratur Gauss (Gaussian Quadrature)}, metode yang sangat akurat dengan memilih titik-titik evaluasi (nodes) secara optimal. % 
\end{enumerate}
Setiap metode akan diuji menggunakan dua fungsi: % 
\begin{itemize}
    \item $f(x) = \cos(x)$ pada interval $[0, \pi/2]$, dengan nilai sejati $\int_0^{\pi/2} \cos(x) \, dx = 1.0$. % 
    \item $f(x) = x^2$ pada interval $[0, 1]$, dengan nilai sejati $\int_0^1 x^2 \, dx = 1/3 \approx 0.333333...$ % 
\end{itemize}
Kita akan mengevaluasi setiap metode berdasarkan pengertian, rumus, implementasi kode (sesuai file yang dilampirkan), hasil perhitungan, dan analisis error. % 
\newpage % 
% ======================================================
% PERBAIKAN 1: Menggunakan \& sebagai ganti &
\section{Metode 1: Aturan Trapesium \& Ekstrapolasi Richardson} % 

\subsection{Pengertian dan Rumus} % 
\textbf{Aturan Trapesium} adalah metode integrasi paling dasar yang mengaproksimasi area di bawah kurva $f(x)$ dengan membaginya menjadi sejumlah trapesium. % 
\begin{itemize}
    \item \textbf{Aturan Trapesium Komposit} untuk $m$ interval dengan lebar $h = (b-a)/m$: % 
    \[ T(h) = \frac{h}{2} \left[ f(a) + 2\sum_{i=1}^{m-1} f(x_i) + f(b) \right] \] % 
\end{itemize}

\textbf{Ekstrapolasi Richardson} adalah teknik umum untuk meningkatkan akurasi dari sebuah estimasi numerik. % 
Jika kita memiliki dua estimasi, $I(h_1)$ dan $I(h_2)$ (misalnya $I(h)$ dan $I(h/2)$), kita dapat menggabungkannya untuk "membatalkan" suku error utama. % 
Untuk Aturan Trapesium, yang memiliki error $O(h^2)$, rumusnya adalah: % 
\[ I_{\text{estimasi}} \approx I(h/2) + \frac{I(h/2) - I(h)}{2^2 - 1} = \frac{4 I(h/2) - I(h)}{3} \] % 
Hasil dari ekstrapolasi ini setara dengan Aturan Simpson. % 
\subsection{Implementasi Kode} % 
Kode berikut (dari \texttt{trapezoidal.py}) mengimplementasikan Aturan Trapesium Komposit untuk kedua fungsi. %  

\begin{lstlisting}[language=Python, caption={Fungsi trapezoidal.py}, label=list:trap] % 
import math
PI = math.pi

def trapezoidal_1(n):
    h = (PI/2)/(n)
    sum = 0
    for i in range(0,n+1):
        if(i==0 or i==n):
            sum += math.cos(i*h)
        else:
            sum += math.cos(i*h) * 2
    return sum * h/2

def trapezoidal_2(n):
    h = 1/(n)
    sum = 0
    for i in range(0,n+1):
        if(i==0 or i==n):
            sum += (i*h)**2
        else:
            sum += (i*h)**2 * 2
    return sum * h/2
\end{lstlisting}  

Kode berikut (dari \texttt{extrapolation.py}) mengimplementasikan Ekstrapolasi Richardson, yang menggunakan fungsi-fungsi dari \texttt{Trapezoidal.py}. Parameter $p$ adalah orde dari error (untuk Trapesium, $p=2$) dan $n$ adalah jumlah interval awal. % 

\begin{lstlisting}[language=Python, caption={Fungsi extrapolation.py}, label=list:extrap]
from trapezoidal import *

def richardson_extrapolation_1(p, n):
    return ((2**p * trapezoidal_1(n*2) - trapezoidal_1(n))/(2**p - 1))

def richardson_extrapolation_2(p, n):
    return ((2**p * trapezoidal_2(n*2) - trapezoidal_2(n))/(2**p - 1))
\end{lstlisting}

\subsection{Hasil Perhitungan dan Analisis Error} % 
Hasil dari kode di atas untuk $m = 1, 2, 4$ (yang setara dengan $R(0,0), R(1,0), R(2,0)$ dalam Romberg) adalah: % 

\begin{table}[H] % 
\centering % 
\caption{Hasil dan Error Aturan Trapesium} % 
\begin{tabular}{l c c c c} % 
\toprule % 
 & \multicolumn{2}{c}{$\int_0^{\pi/2} \cos(x) \, dx$ (Sejati: 1.0)} & \multicolumn{2}{c}{$\int_0^1 x^2 \, dx$ (Sejati: 1/3)} \\ % 
$m$ (Interval) & Hasil Trapesium & Error Absolut & Hasil Trapesium & Error Absolut \\ % 
\midrule % 
1 ($R(0,0)$) & 0.785398 & % 
0.214602 & 0.500000 & 0.166667 \\ % 
2 ($R(1,0)$) & 0.948059 & 0.051941 & 0.375000 & 0.041667 \\ % 
4 ($R(2,0)$) & 0.987116 & 0.012884 & 0.343750 & 0.010417 \\ % 
\bottomrule % 
\end{tabular} % 
\end{table} % 

\textbf{Analisis (Aturan Trapesium):} Error dari Aturan Trapesium cukup besar, tetapi berkurang sekitar faktor 4 setiap kali jumlah interval dikalikan dua (sesuai dengan $O(h^2)$). % 

% --- [BLOK TAMBAHAN UNTUK RICHARDSON] ---
\begin{table}[H] 
\centering 
\caption{Hasil dan Error Ekstrapolasi Richardson ($p=2$)} 
\begin{tabular}{l c c c c} 
\toprule 
 & \multicolumn{2}{c}{$\int_0^{\pi/2} \cos(x) \, dx$ (Sejati: 1.0)} & \multicolumn{2}{c}{$\int_0^1 x^2 \, dx$ (Sejati: 1/3)} \\ 
$n$ (Basis) & Hasil Ekstrapolasi & Error Absolut & Hasil Ekstrapolasi & Error Absolut \\ 
\midrule 
$n=1$ ($T_1, T_2$) & 1.002279 & $2.28 \times 10^{-3}$ & 0.333333... & 0.0 \\ 
$n=2$ ($T_2, T_4$) & 1.000135 & $1.35 \times 10^{-4}$ & 0.333333... & 0.0 \\ 
\bottomrule 
\end{tabular} 
\end{table} 

\textbf{Analisis (Ekstrapolasi Richardson):} Dengan menerapkan Ekstrapolasi Richardson (setara dengan nilai $R(1,1)$ dan $R(2,1)$ dari tabel Romberg), akurasi meningkat secara drastis dibandingkan Trapesium murni.
\begin{itemize}
    \item \textbf{$\cos(x)$:} Error berkurang dari $1.29 \times 10^{-2}$ (Trapesium $m=4$) menjadi $1.35 \times 10^{-4}$ (Ekstrapolasi $n=2$). Ini adalah peningkatan akurasi yang signifikan hanya dengan menggabungkan hasil yang sudah ada.
    \item \textbf{$x^2$:} Metode ini langsung memberikan hasil \textbf{eksak} (Error = 0). Ini karena ekstrapolasi orde pertama pada Aturan Trapesium ($p=2$) secara matematis identik dengan Aturan Simpson, yang diketahui eksak untuk polinomial derajat $\le 3$.
\end{itemize}
% --- [AKHIR BLOK TAMBAHAN] ---

\newpage % 
% ======================================================
\section{Metode 2: Integrasi Romberg} % 

\subsection{Pengertian dan Rumus} % 
Integrasi Romberg adalah aplikasi rekursif dan sistematis dari Ekstrapolasi Richardson pada Aturan Trapesium. % 
Metode ini membangun tabel $R(i, j)$ di mana: % 
\begin{itemize}
    \item \textbf{Kolom Pertama $R(i, 0)$:} Adalah hasil Aturan Trapesium dengan $m = 2^i$ interval. % 
    \[ R(i, 0) = \text{trapezoidal\_rule}(2^i) \] % 
    \item \textbf{Kolom Berikutnya $R(i, j)$:} Adalah hasil ekstrapolasi dari kolom sebelumnya. % 
    \[ R(i, j) = \frac{4^j R(i, j-1) - R(i-1, j-1)}{4^j - 1} \] % 
\end{itemize}
Nilai $R(i, 1)$ setara dengan Aturan Simpson, $R(i, 2)$ setara dengan Aturan Boole, dst. % 
Perkiraan terbaik adalah nilai di diagonal, $R(n, n)$. % 

\subsection{Implementasi Kode} % 
Kode berikut (dari \texttt{Integration.py}) mengimplementasikan fungsi Romberg secara rekursif dan membangun tabel $3 \times 3$ (hingga $R(2,2)$). % 
\begin{lstlisting}[language=Python, caption={Fungsi romberg.py}, label=list:romberg] 
from trapezoidal import *

def romberg_1(m, n):
    if(n==0):
        return trapezoidal_1(2**m)
    return (4**n * romberg_1(m, n-1) - romberg_1(m-1, n-1)) / (4**n - 1)

def romberg_2(m, n):
    if(n==0):
        return trapezoidal_2(2**m)
    return (4**n * romberg_2(m, n-1) - romberg_2(m-1, n-1)) / (4**n - 1)
\end{lstlisting} % 

\subsection{Hasil Perhitungan dan Analisis Error} % 
Output dari kode di atas menghasilkan tabel berikut (hingga $R(2,2)$): % 

\textbf{Tabel Romberg % 
untuk $\int_0^{\pi/2} \cos(x) \, dx$ (Sejati: 1.0)} % 
\begin{table}[H] % 
\centering % 
\begin{tabular}{llll} % 
\toprule % 
$i$ & $j=0$ (Trapesium) & $j=1$ (Simpson) & $j=2$ (Boole) \\ % 
\midrule % 
0 & 0.785398 & & \\ % 
1 & 0.948059 & 1.002279 & \\ % 
2 & 0.987116 & 1.000135 & 0.999992 \\ %  <-- BOLD REMOVED
\bottomrule % 
\end{tabular} % 
\end{table} % 

\textbf{Tabel Romberg untuk $\int_0^1 x^2 \, dx$ (Sejati: 1/3)} % 
\begin{table}[H] % 
\centering % 
\begin{tabular}{llll} % 
\toprule % 
$i$ & $j=0$ (Trapesium) & $j=1$ (Simpson) & $j=2$ (Boole) \\ % 
\midrule % 
0 & 0.500000 & & \\ % 
1 & 0.375000 & 0.333333... & \\ % 
2 & 0.343750 & 0.333333... & 0.333333... \\ % <-- BOLD REMOVED
\bottomrule % 
\end{tabular} % 
\end{table} % 

\textbf{Analisis:} % 
\begin{itemize}
    \item \textbf{$\cos(x)$:} Perkiraan terbaik $R(2,2) = 0.999992$. % 
    Error absolutnya adalah $|1.0 - 0.999992| = 8.0 \times 10^{-6}$. % 
    Ini adalah peningkatan akurasi yang sangat signifikan dibandingkan Trapesium $R(2,0)$ (Error $0.0128$). % 
    \item \textbf{$x^2$:} Metode ini memberikan hasil \textbf{eksak} $1/3$ (Error = 0) sudah pada $R(1,1)$. % 
    Ini karena $R(i, 1)$ setara dengan Aturan Simpson, yang secara definisi eksak untuk polinomial derajat $\le 3$. % 
\end{itemize}

\newpage % 
% ======================================================
\section{Metode 3: Integrasi Adaptif (Adaptive Quadrature)} % 

\subsection{Pengertian dan Rumus} % 
Integrasi Adaptif adalah metode yang cerdas. % 
Alih-alih menggunakan ukuran langkah $h$ yang tetap di seluruh interval, metode ini "mengadaptasi" ukuran langkahnya. % 
\begin{itemize}
    \item Ia menggunakan langkah besar (hemat komputasi) di area di mana fungsi $f(x)$ relatif datar. % 
    \item Ia menggunakan langkah kecil (perhitungan lebih intensif) di area di mana fungsi $f(x)$ berfluktuasi tajam. % 
\end{itemize}
Kode yang dilampirkan menggunakan Aturan Simpson sebagai basis. Ia membandingkan estimasi Simpson pada satu interval besar ($I_1$) dengan jumlah dua estimasi Simpson pada dua sub-interval ($I_2$). % 
Jika $|I_2 - I_1|$ lebih besar dari toleransi (tol), interval dibagi dua dan proses diulang secara rekursif. % 
Rumus estimasi errornya adalah $E \approx |I_2 - I_1|$. Perkiraan integral yang lebih baik (koreksi orde ke-4) adalah $I = I_2 + (I_2 - I_1)/15$. % 
\subsection{Implementasi Kode} % 
Kode berikut (dari \texttt{adaptive-integration.py}) mengimplementasikan metode adaptif berbasis Simpson. % 
\begin{lstlisting}[language=Python, caption={Fungsi adaptive-integration.py}, label=list:adaptive]
import math
PI = math.pi

def quadpt_1(a, b):
    tol = 1e-10
    c = (a+b)/2
    fa = math.cos(a)
    fb = math.cos(b)
    fc = math.cos(c)
    I, E = qstep_1(a, b, tol, fa, fc, fb)
    return I, E

def qstep_1(a, b, tol, fa, fc, fb):
    h1 = (b - a)/2
    h2 = h1/2
    c = (a + b)/2
    fd = math.cos((a + c)/2)
    fe = math.cos((c + b)/2)
    I1 = h1/3 * (fa + 4*fc + fb)
    I2 = h2/3 * (fa + 4*fd + 2*fc + 4*fe + fb)

    E = abs(I2 - I1)  # estimated local error
    
    if E < tol:
        I = I2 + (I2 - I1) / 15
        return I, E
    else:
        Ia, Ea = qstep_1(a, c, tol / 2, fa, fd, fc)
        Ib, Eb = qstep_1(c, b, tol / 2, fc, fe, fb)
        return Ia + Ib, Ea + Eb

def quadpt_2(a, b):
    tol = 1e-10
    c = (a+b)/2
    fa = a**2
    fb = b**2
    fc = c**2
    I, E = qstep_2(a, b, tol, fa, fc, fb)
    return I, E

def qstep_2(a, b, tol, fa, fc, fb):
    h1 = (b - a)/2
    h2 = h1/2
    c = (a + b)/2
    fd = ((a + c)/2)**2
    fe = ((c + b)/2)**2
    I1 = h1/3 * (fa + 4*fc + fb)
    I2 = h2/3 * (fa + 4*fd + 2*fc + 4*fe + fb)

    E = abs(I2 - I1)  # estimated local error
    
    if E < tol:
        I = I2 + (I2 - I1) / 15
        return I, E
    else:
        Ia, Ea = qstep_2(a, c, tol / 2, fa, fd, fc)
        Ib, Eb = qstep_2(c, b, tol / 2, fc, fe, fb)
        return Ia + Ib, Ea + Eb
\end{lstlisting} 

\subsection{Hasil Perhitungan dan Analisis Error} % 
Output dari kode di atas (dengan $\text{tol} = 10^{-10}$): % 

\textbf{Hasil untuk $\int_0^{\pi/2} \cos(x) \, dx$:} % 

\begin{lstlisting}[language={}, caption={}, numbers=none] 
Aproximation first integral: 0.9999999999999999
Estimated local error: 2.669869663893265e-11
\end{lstlisting} 

\textbf{Hasil % 
untuk $\int_0^1 x^2 \, dx$:} 

\begin{lstlisting}[language={}, caption={}, numbers=none] 
Aproximation first integral: 0.3333333333333333
Estimated local error: 0.0
\end{lstlisting} % 

\textbf{Analisis:} % 
\begin{itemize}
    \item \textbf{$\cos(x)$:} Metode ini mencapai nilai \textbf{1.0}, yang sangat akurat. % 
    Error aktualnya (terbatas oleh presisi float) jauh lebih kecil dari error Romberg $R(2,2)$, dan dicapai secara efisien dengan berhenti ketika toleransi terpenuhi. % 
    \item \textbf{$x^2$:} Metode ini memberikan hasil \textbf{eksak} $1/3$ dan estimasi error $0.0$. % 
    Ini karena basisnya adalah Aturan Simpson, yang (seperti disebutkan) eksak untuk polinomial derajat $\le 3$. % 
\end{itemize}

\newpage % 
% ======================================================
\section{Metode 4: Kuadratur Gauss (Gaussian Quadrature)} % 

\subsection{Pengertian dan Rumus} % 
Kuadratur Gauss (secara spesifik Gauss-Legendre) adalah metode yang sangat berbeda dan kuat. Alih-alih menggunakan titik-titik yang berjarak sama (seperti Trapesium/Simpson), metode ini secara cerdas memilih $n$ titik (disebut \textbf{nodes}, $x_i$) dan \textbf{bobot} ($w_i$) yang optimal. 

Implementasi Kuadratur Gauss menggunakan \textit{library} seperti NumPy karena metode ini fundamentalnya bergantung pada sekumpulan "nodes" (titik $x_i$) dan "weights" (bobot $w_i$) yang optimal, yang merupakan akar-akar dari Polinomial Legendre. Menghitung nilai-nilai ini dari awal adalah tugas matematika yang sangat kompleks dan intensif secara komputasi, membutuhkan algoritma pencarian akar numerik yang canggih. \textit{Library} \texttt{numpy} menyediakan fungsi \texttt{leggauss(n)} yang langsung memberikan nilai-nilai presisi tinggi ini secara instan, sehingga kita bisa fokus pada logika integrasinya (transformasi interval dan penjumlahan $\sum w_i f(t_i)$) tanpa harus mengimplementasikan ulang kalkulasi matematika yang rumit tersebut.
\begin{itemize}
    \item Titik-titik ini adalah akar dari Polinomial Legendre. % 
    \item Keajaibannya adalah: $n$-titik Kuadratur Gauss dapat mengintegrasikan polinomial derajat $\le 2n-1$ secara \textbf{eksak}. % 
\end{itemize}
Rumus dasarnya adalah untuk interval $[-1, 1]$: % 
\[ \int_{-1}^{1} g(x) \, dx \approx \sum_{i=1}^n w_i g(x_i) \] % 
Untuk mengubah interval $[a, b]$ ke $[-1, 1]$, kita gunakan transformasi: % 
\[ t = \frac{x+1}{2}(b-a) + a \quad \implies \quad \int_a^b f(t) \, dt \approx \frac{b-a}{2} \sum_{i=1}^n w_i f(t_i) \] % 

\subsection{Implementasi Kode} % 
Kode berikut (dari \texttt{gauss\_1.py} dan \texttt{gauss\_2.py}) mengimplementasikan Kuadratur Gauss menggunakan \texttt{numpy} untuk mendapatkan nilai $x_i$ dan $w_i$. % 

% --- [MODIFIKASI GAUSS CODE BLOCKS: VERTICAL] ---
\begin{figure}[H]
    \centering % Opsional: untuk menengahkan blok kode
    
    % --- Kode Pertama ---
    \begin{lstlisting}[language=Python, caption={Fungsi gauss.py (untuk $\cos(x)$)}, label=list:gauss1] 
    import numpy as np
    import math
    pi = math.pi

    def gauss_1(a, b, n):
        x, w = np.polynomial.legendre.leggauss(n)
        t = (x+1)*(b-a)/2 + a
        return (b-a)*np.sum(w*np.cos(t))/2
    \end{lstlisting} 
    
    \vspace{1em} % Memberi sedikit jarak vertikal antar blok kode

    % --- Kode Kedua ---
    \begin{lstlisting}[language=Python, caption={Fungsi gauss.py (untuk $x^2$)}, label=list:gauss2]
    import numpy as np
    
    def gauss_2(a, b, n):
        x, w = np.polynomial.legendre.leggauss(n)
        t = (x+1)*(b-a)/2 + a
        return (b-a)*np.sum(w*(t**2))/2
    \end{lstlisting} 
    
    % --- Caption Utama ---
    \caption{Implementasi Kuadratur Gauss}
\end{figure}
% --- [AKHIR MODIFIKASI GAUSS] ---


\subsection{Hasil Perhitungan dan Analisis Error} % 
Output dari kode di atas untuk $n=1$ sampai $n=5$ titik: % 

\begin{table}[H] % 
\centering % 
\caption{Hasil dan Error Kuadratur Gauss} % 
\begin{tabular}{l c c c c} % 
\toprule % 
 & \multicolumn{2}{c}{$\int_0^{\pi/2} \cos(x) \, dx$ (Sejati: 1.0)} & \multicolumn{2}{c}{$\int_0^1 x^2 \, dx$ (Sejati: 1/3)} \\ % 
$n$ (Titik) & Hasil Gauss & Error Absolut & Hasil Gauss & Error Absolut \\ % 
\midrule % 
% --- [PERBAIKAN TABEL GAUSS] ---
1 & 0.998475 & $1.52 \times 10^{-3}$ & 0.250000 & $\approx 8.33 \times 10^{-2}$ \\ % 
2 & 1.000003 & $3.00 \times 10^{-6}$ & 0.333333... & 0.0 \\ % 
3 & 0.9999999996 & $3.31 \times 10^{-10}$ & 0.333333... & 0.0 \\ % 
4 & 1.0000000000 % 
& $\approx 0.0$ & 0.333333... & 0.0 \\ % 
\bottomrule % 
\end{tabular} % 
\end{table} % 
% --- [CATATAN GAUSS DIHAPUS] ---
\textbf{Analisis:} % 
\begin{itemize}
    \item \textbf{$\cos(x)$:} Konvergensi sangat cepat. Hanya dengan $n=3$ titik, error sudah $\approx 10^{-10}$. % 
    Dengan $n=4$ titik, hasilnya sudah akurat hingga presisi mesin. % 
    \item \textbf{$x^2$:} Kuadratur Gauss $n=1$ (setara Aturan Titik Tengah) memberikan hasil $0.25$. Metode ini memberikan hasil \textbf{eksak} $1/3$ (Error = 0) dimulai dari $n=2$ titik, sesuai dengan teorinya ($2n-1 = 3$). % 
\end{itemize}

\newpage % 
% ======================================================
\section{Kesimpulan: Perbandingan Error} % 

Mari kita rangkum perkiraan terbaik dari setiap metode untuk kedua fungsi dalam tabel perbandingan. % 
% PERBAIKAN 2: Mengganti \subsubsection menjadi \subsection untuk hierarki yang benar
\subsection{Perbandingan untuk $\int_0^{\pi/2} \cos(x) \, dx$ (Sejati: 1.0)} % 

% --- [MODIFIKASI TABEL KESIMPULAN 1 DENGAN RICHARDSON, BOLD DIHAPUS] ---
\begin{table}[H] % 
\centering % 
\begin{tabular}{l l l l} % 
\toprule % 
Metode & Perkiraan Terbaik & Error Absolut & Catatan \\ % 
\midrule % 
Trapesium & 0.987116 & $\approx 1.29 \times 10^{-2}$ & $m=4$ interval ($R(2,0)$) \\ % 
Ekstrapolasi & 1.000135 & $\approx 1.35 \times 10^{-4}$ & Basis $m=2$ \& $m=4$ ($R(2,1)$) \\ % 
Romberg & 0.999992 & $\approx 8.0 \times 10^{-6}$ & $R(2,2)$, (basis $m=4$) \\ % 
Adaptif & 0.999999... & $\approx 2.67 \times 10^{-11}$ & (Estimasi error oleh kode) \\ % 
Gauss & 1.000000... & $\approx 2.22 \times 10^{-16}$ & $n=4$ titik (Presisi mesin) \\ % 
\bottomrule % 
\end{tabular} % 
\end{table} % 
% --- [AKHIR MODIFIKASI] ---

% PERBAIKAN 3: Mengganti \subsubsection menjadi \subsection untuk hierarki yang benar
\subsection{Perbandingan untuk $\int_0^1 x^2 \, dx$ (Sejati: 1/3)} % 

% --- [MODIFIKASI TABEL KESIMPULAN 2 DENGAN RICHARDSON, BOLD DIHAPUS] ---
\begin{table}[H] % 
\centering % 
\begin{tabular}{l l l l} % 
\toprule % 
Metode % 
& Perkiraan Terbaik & Error Absolut & Catatan \\ % 
\midrule % 
Trapesium & 0.343750 & $\approx 1.04 \times 10^{-2}$ & $m=4$ interval ($R(2,0)$) \\ % 
Ekstrapolasi & 0.333333... & 0.0 & Eksak (setara Simpson) \\ % 
Romberg & 0.333333... & 0.0 & Eksak pada $R(1,1)$ \\ % 
Adaptif & 0.333333... & 0.0 & Eksak (basis Simpson) \\ % 
Gauss & 0.333333... & 0.0 & Eksak pada $n=2$ titik \\ % 
\bottomrule % 
\end{tabular} % 
\end{table} % 
% --- [AKHIR MODIFIKASI] ---

% --- [MODIFIKASI ANALISIS KESIMPULAN DENGAN RICHARDSON] ---
\subsection{Metode dengan Error Terkecil} % 
\begin{itemize}
    \item \textbf{Untuk $f(x) = x^2$ (Polinomial Sederhana):} % 
    Metode \textbf{Ekstrapolasi Richardson}, \textbf{Romberg}, \textbf{Integrasi Adaptif}, dan \textbf{Kuadratur Gauss} ($n \ge 2$) semuanya menghasilkan error nol (0.0) dan memberikan jawaban eksak. % 
    Ini karena Ekstrapolasi Richardson (dan juga basis dari Romberg $R(i,1)$ serta Integrasi Adaptif) secara matematis setara dengan Aturan Simpson, yang eksak untuk polinomial derajat $\le 3$. % 
    Kuadratur Gauss ($n=2$) juga eksak untuk polinomial derajat $\le 3$. % 
    
    \item \textbf{Untuk $f(x) = \cos(x)$ (Fungsi Transendental):} % 
    Di sini kita melihat progresi akurasi yang jelas: Aturan Trapesium ($10^{-2}$), diikuti oleh Ekstrapolasi Richardson ($10^{-4}$), lalu Integrasi Romberg ($10^{-6}$).
    Namun, metode \textbf{Integrasi Adaptif} dan \textbf{Kuadratur Gauss} ($n \ge 4$) adalah pemenangnya, keduanya menghasilkan error terkecil yang pada dasarnya dibatasi oleh presisi floating-point komputer ($\approx 10^{-16}$). % 
    Integrasi Romberg jauh lebih baik daripada Trapesium dasar, tetapi akurasinya (untuk jumlah evaluasi fungsi yang sebanding) dikalahkan oleh efisiensi Integrasi Adaptif dan kekuatan Kuadratur Gauss. % 
\end{itemize}
% --- [AKHIR BLOK PENGGANTI] ---

\end{document} % 
% ======================================================
%               AKHIR DOKUMEN
% ======================================================